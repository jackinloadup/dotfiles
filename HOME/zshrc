export EDITOR="vim"
export LANG=en_US.UTF-8

bindkey "^B" history-beginning-search-backward

# dont use oh-my-zsh auto complete
unsetopt correct_all

setopt autopushd

# Comment this out to disable weekly auto-update checks
export DISABLE_AUTO_UPDATE="true"

# Uncomment following line if you want to disable autosetting terminal title.
# export DISABLE_AUTO_TITLE="true"

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(git)

# this is a great place to store local settings like $PATH
[[ -f ~/.bash_profile ]] && . ~/.bash_profile

# place per machine/user settings here
[[ -f ~/.zshrc.local ]] && . ~/.zshrc.local

# for the lulz
alias hack="cat /dev/urandom | hexdump"

# vegeta is the name of my machine
if [[ $(hostname -s) == "vegeta" ]]; then
  alias wi='ssh wi -t tmux a'
  alias opus='ssh opus -t su -c "tmux\ a" root'

  # if phpcs is installed lets assume the code stanards tool is installed
  if type "phpcs" &> /dev/null; then
    alias drupalcs="phpcs --standard=$(pear config-get php_dir)/PHP/CodeSniffer/Standards/Drupal/ruleset.xml --extensions=php,module,inc,install,test,profile,theme media.module"
  fi
fi

# if tmux make force get zsh to not be stupid and use 256 color mode
if [[ ${+TMUX} == 1 ]]; then
  export TERM=screen-256color
elif [[ ${TERM} != "xterm-256color" ]]; then
  if [[ $(toe /usr/share/terminfo | grep -o 'xterm-256color' | tr -s ' ') == 'xterm-256color' ]]; then
    export TERM='xterm-256color'
  fi
fi

unsetopt correct_all

# override lukerandall theme function
function my_git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null)
  if [[ $ref == refs* ]]; then
    git="${ref#refs/heads/}"
  elif [[ -n $(git describe --exact-match HEAD 2> /dev/null) ]]; then
    git=$(git describe --exact-match HEAD 2> /dev/null)
  elif [[ -n $(git describe HEAD 2> /dev/null) ]]; then
    git=$(git describe HEAD | sed "s/.\{9\}$//g" | sed "s/-/+/"  2> /dev/null)
  fi

  GIT_STATUS=$(git_prompt_status)
  [[ -n $GIT_STATUS ]] && GIT_STATUS=" $GIT_STATUS"

  if [[ $git =~ .+ ]]; then
    echo "$ZSH_THEME_GIT_PROMPT_PREFIX$git$GIT_STATUS$ZSH_THEME_GIT_PROMPT_SUFFIX";
  fi
}

# Less Colors for Man Pages
export LESS_TERMCAP_mb=$'\E[01;31m'       # begin blinking
export LESS_TERMCAP_md=$'\E[01;38;5;74m'  # begin bold
export LESS_TERMCAP_me=$'\E[0m'           # end mode
export LESS_TERMCAP_se=$'\E[0m'           # end standout-mode
export LESS_TERMCAP_so=$'\E[38;5;246m'    # begin standout-mode - info box
export LESS_TERMCAP_ue=$'\E[0m'           # end underline
export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline

if hash git-setup-user 2>/dev/null; then
  git-setup-user
fi

# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -A key

key[Home]=${terminfo[khome]}

key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}

# setup key accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init () {
        printf '%s' "${terminfo[smkx]}"
    }
    function zle-line-finish () {
        printf '%s' "${terminfo[rmkx]}"
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi
